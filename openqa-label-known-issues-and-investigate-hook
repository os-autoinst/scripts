#!/bin/bash

set -eo pipefail

dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

PATH=$dir:$PATH

# shellcheck source=/dev/null
source "$dir"/_common

host="${host:-"openqa.opensuse.org"}"
scheme="${scheme:-"https"}"
host_url="$scheme://$host"

investigate-and-bisect() {
    local rc=0 test
    read -r test || rc=$?
    [[ -n "$test" ]] || return 0
    rc=0
    openqa-investigate "$test" || rc=$?
    [[ "$rc" -eq 142 ]] && return "$rc"
    openqa-trigger-bisect-jobs --url "$test" || rc=$?
    return "$rc"
}

label() {
    local url=$1
    openqa-label-known-issues "$url" | sed -n 's/\[\([^]]*\)\].*Unknown test issue, to be reviewed.*/\1/p'
}

hook() {
    opts=$(getopt -o h -l help -n "$0" -- "$@") || usage 1
    eval set -- "$opts"
    while true; do
        case "$1" in
            -h | --help) usage 0 ;;
            --)
                shift
                break
                ;;
            *) break ;;
        esac
    done
    local id="${1:?"Need 'job_id'"}"
    local url=$host_url/tests/$id
    local rc=0
    job_data=$(openqa-api-get "jobs/$id") || rc=$?
    # shellcheck disable=SC2154
    [[ $job_data =~ $not_found_regex ]] && warn "Ignoring non-existent job $id" && return
    [[ $rc != 0 ]] && return $rc
    state="$(echo "$job_data" | runjq -r '.job.state')" || return $?
    result="$(echo "$job_data" | runjq -r '.job.result')" || return $?
    [[ "$state" != "done" ]] && return
    if [[ "$result" != passed ]]; then
        label "$url" | investigate-and-bisect
    else
        echo "$url" | investigate-and-bisect
    fi
}

usage() {
    cat << EOF
Usage: $0 [OPTIONS]

"hook script" intended to be called by openQA instances taking a job ID as
parameter and forwarding a complete job URL to "openqa-label-known-issues" on
stdin and all left unknowns to "openqa-investigate"

Options:
 -h, --help         display this help
EOF
    exit "$1"
}

caller 0 > /dev/null || hook "$@"
